/****************************************************************************
 * C# to Qt portation, Linux developing                                     *
 * flex/bison SVG parser                                                    *
 * Copyright (C) 2015-2018 by Eduard Kalinowski                             *
 * Germany, Lower Saxony, Hanover                                           *
 * eduard_kalinowski@yahoo.de                                               *
 *                                                                          *
 * C# project CNC-controller-for-mk1                                        *
 * https://github.com/selenur/CNC-controller-for-mk1                        *
 *                                                                          *
 * The Qt project                                                           *
 * https://github.com/eduard-x/cnc-qt                                       *
 *                                                                          *
 * CNC-Qt is free software; may be distributed and/or modified under the    *
 * terms of the GNU General Public License version 3 as published by the    *
 * Free Software Foundation and appearing in the file LICENSE_GPLv3         *
 * included in the packaging of this file.                                  *
 *                                                                          *
 * This program is distributed in the hope that it will be useful,          *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of           *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            *
 * GNU General Public License for more details.                             *
 *                                                                          *
 * You should have received a copy of the GNU Lesser General Public         *
 * License along with CNC-Qt. If not, see  http://www.gnu.org/licenses      *
 ****************************************************************************/
 

%{

#include "GData.h"
extern int svglineno;

%}

/* C++ parser interface */
%skeleton "lalr1.cc"
%require  "3.0"

// The parsing context.
%parse-param { svg::driver& checker }
%lex-param   { svg::driver& checker }

%locations

%initial-action
{
    // Initialize the initial location.
    @$.begin.filename = @$.end.filename = &checker.file;
};
/* increase usefulness of error messages */
%define parse.error verbose
%define api.namespace {svg}
/* assert correct cleanup of semantic value objects */
%define parse.assert

%define api.value.type variant
%define api.token.prefix {T_}



%token MOVE_REL MOVE_ABS
%token HLINE_REL HLINE_ABS VLINE_REL VLINE_ABS
%token LINETO_ABS LINETO_REL
%token CURVE_ABS CURVE_REL
%token SMOOTH_ABS SMOOTH_REL
%token ARC_ABS ARC_REL
%token QCURVE_REL QCURVE_ABS
%token SMOOTH_QCURVE_ABS SMOOTH_QCURVE_REL
%token CLOSEPATH

%token INT
%token HEXVAL
%token FLOAT
%token NEW_LINE

%token InvalidCharacter

%token ' ' ','


%token END     0   "end of file"

%token <std::string> NAME ID_NAME
%token <std::string> STR
%token <char> CHAR OPER

%type <int> INT HEXVAL
%type <float> FLOAT



%code requires {
    #include <QString>
    #include <QChar>
    #include <QDebug>
    #include <QVector>
    #include <stdexcept>
    #include <string>

    #include "location.hh"

    namespace svg {
        class scanner;
        class driver;
    };
}

%code {
    #include "Settings.h"
    #include "SVGScanner.h"
    
    // initializing for vector
    SVGData *svg_data = new SVGData();
}


%start parse_svg

%%

parse_svg: 
        | tags
        ;

tags:   tag 
        | tag tags
        ;
        
tag:    NAME attribs
        | attribs
        ;


attribs: attrib 
        | attrib attribs
        ;


attrib: NAME EXPRS
        {
            qInfo() << "attr name" << QString($1.c_str());
        }
        | NAME 
        {
            /* ignore if only NAME of attribute, URL was removed for example */
        }
        | NEW_LINE
        ;


EXPRS:  EXPR 
        | EXPR EXPRS
        ;


EXPR:   STR 
        {
            qInfo() << "str" << QString($1.c_str()) << svglineno;
        }
        | ID_NAME 
        {
            qInfo() << "str" << QString($1.c_str()) << svglineno;
        }
        | MOVE_ABS FLOAT ' ' FLOAT
        {
            /* move x y */
            /* ignore first space character after drawing char, when this exists */ 
            qInfo() << "move abs" << $2 << $4;
        }
        | MOVE_REL FLOAT ' ' FLOAT
        {
            /* move x y */
            qInfo() << "move rel" << $2 << $4;
        }
        | HLINE_REL FLOAT
        {
            /* horizontal line to x */
            qInfo() << "horline rel" << $2; 
        }
        | HLINE_ABS FLOAT
        {
            /* horizontal line to x */
            qInfo() << "horline abs" << $2;
        }
        | VLINE_REL FLOAT
        {
            /* vetical line to y */
            qInfo() << "verline rel" << $2;
        }
        | VLINE_ABS FLOAT
        {
            /* vetical line to y */
            qInfo() << "verline abs" << $2; 
        }
        | LINETO_ABS FLOAT ' ' FLOAT 
        {
            /* line to x y */
            qInfo() << "lineto abs" << $2 << $4;
        }
        | LINETO_REL FLOAT ' ' FLOAT 
        {
            /* line to x y */
            qInfo() << "lineto rel" << $2 << $4;
        }
        | CURVE_ABS FLOAT ' ' FLOAT ' ' FLOAT ' ' FLOAT ' ' FLOAT ' ' FLOAT 
        {
            /* cubic bezier curve x1 y1 x2 y2 x y */ 
            qInfo() << "curve abs";
        }
        | CURVE_REL FLOAT ' ' FLOAT ' ' FLOAT ' ' FLOAT ' ' FLOAT ' ' FLOAT 
        {
            /* cubic bezier curve x1 y1 x2 y2 x y */ 
            qInfo() << "curve rel";
        }
        | SMOOTH_ABS FLOAT ' ' FLOAT ' ' FLOAT ' ' FLOAT 
        {
            /* cubic bezier curve x2 y2 x y */ 
            qInfo() << "smooth abs";
        }
        | SMOOTH_REL FLOAT ' ' FLOAT ' ' FLOAT ' ' FLOAT 
        {
            /* cubic bezier curve x2 y2 x y */ 
            qInfo() << "smooth rel";
        }
        | ARC_ABS FLOAT ' ' FLOAT ' ' FLOAT ' ' FLOAT ' ' FLOAT ' ' FLOAT ' ' FLOAT 
        {
            /* elliptical Arc rx ry x-rotation lage-arc-flag sweep-flag x y */
            qInfo() << "arc abs";
        }
        | ARC_REL FLOAT ' ' FLOAT ' ' FLOAT ' ' FLOAT ' ' FLOAT ' ' FLOAT ' ' FLOAT 
        {
            /* elliptical Arc rx ry x-rotation lage-arc-flag sweep-flag x y */
            qInfo() << "arc rel";
        }
        | QCURVE_ABS FLOAT ' ' FLOAT ' ' FLOAT ' ' FLOAT 
        {
            /* quadratic bezier curve x1 y1 x y */ 
            qInfo() << "qcurve abs";
        }
        | QCURVE_REL FLOAT ' ' FLOAT ' ' FLOAT ' ' FLOAT 
        {
            /* quadratic bezier curve x1 y1 x y */ 
            qInfo() << "qcurve rel";
        }
        | SMOOTH_QCURVE_ABS FLOAT ' ' FLOAT 
        {
            /* smooth quadratic Bézier curve x y */
            qInfo() << "smooth qcurve abs";
        }
        | SMOOTH_QCURVE_REL FLOAT ' ' FLOAT 
        {
            /* smooth quadratic Bézier curve x y */
            qInfo() << "smooth qcurve rel";
        }
        | CLOSEPATH
        {
            qInfo() << "closepath";
        }
        | HEXVAL 
        {
            qInfo() << "hex " << $1;
        }
        | INT 
        {
            qInfo() << "int " << $1;
        }
        | FLOAT
        {
            qInfo() << "float " << $1;
        }
        | ' '
        {
            qInfo() << "separator";
        }
        ;

%%


void svg::parser::error ( const svg::parser::location_type& l, const std::string& m)
{
    checker.error (l, m);
}
